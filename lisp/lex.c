/* Generated by re2c 1.1.1 on Wed Dec 12 08:11:07 2018 */
#line 1 "lex.re"
#include "lex.h"

#include <string.h>
#include <stdlib.h>

struct lexer *
new_lexer(const char *file, const char *s)
{
	struct lexer *l = malloc(sizeof *l);
	memset(l, 0, sizeof *l);

	l->s = s;
	l->e = s + strlen(s);
	l->file = file;
	l->loc.file = file;
	l->loc.text = s;

	return l;
}

#define YYCTYPE char
#define YYFILL(X) do {} while (0)
#define YYMARKER (*a)
#define YYCURSOR (*b)

static int
lex1(const char **a,
     const char **b,
     unsigned *line,
     unsigned *column,
     const char *YYLIMIT)
{
 loop:
	YYMARKER = YYCURSOR;
	
#line 39 "lex.c"
{
	YYCTYPE yych;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy2;
	case '\t':
	case '\v':
	case '\r':
	case ' ':	goto yy6;
	case '\n':	goto yy8;
	case '!':
	case '"':
	case '$':
	case '%':
	case '&':
	case '\'':
	case '(':
	case ')':
	case '*':
	case '+':
	case ',':
	case '-':
	case '.':
	case '/':
	case ':':
	case ';':
	case '<':
	case '=':
	case '>':
	case '?':
	case '@':
	case '[':
	case '\\':
	case ']':
	case '^':
	case '_':
	case '`':
	case '{':
	case '|':
	case '}':
	case '~':	goto yy10;
	case '#':	goto yy12;
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy15;
	default:	goto yy4;
	}
yy2:
	++YYCURSOR;
#line 42 "lex.re"
	{ YYCURSOR--; return TOK_EOF; }
#line 151 "lex.c"
yy4:
	++YYCURSOR;
#line 41 "lex.re"
	{ *b = NULL; return -1; }
#line 156 "lex.c"
yy6:
	++YYCURSOR;
#line 37 "lex.re"
	{ (*column)++; goto loop; }
#line 161 "lex.c"
yy8:
	++YYCURSOR;
#line 36 "lex.re"
	{ (*line)++, *column = 0; goto loop; }
#line 166 "lex.c"
yy10:
	++YYCURSOR;
#line 39 "lex.re"
	{ return **a; }
#line 171 "lex.c"
yy12:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy14;
	default:	goto yy12;
	}
yy14:
#line 38 "lex.re"
	{ goto loop; }
#line 183 "lex.c"
yy15:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy15;
	default:	goto yy17;
	}
yy17:
#line 40 "lex.re"
	{ return TOK_IDENT; }
#line 256 "lex.c"
}
#line 43 "lex.re"

}

static int
lex2(const char **a,
     const char **b,
     unsigned *line,
     unsigned *column,
     const char *YYLIMIT)
{
 loop:
	YYMARKER = YYCURSOR;
	
#line 272 "lex.c"
{
	YYCTYPE yych;
	if ((YYLIMIT - YYCURSOR) < 3) YYFILL(3);
	yych = *YYCURSOR;
	switch (yych) {
	case 0x00:	goto yy20;
	case '\t':
	case '\v':
	case '\r':
	case ' ':	goto yy24;
	case '\n':	goto yy26;
	case '!':
	case '$':
	case '%':
	case '*':
	case '+':
	case '-':
	case '/':
	case '<':
	case '=':
	case '>':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case '^':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy28;
	case '"':	goto yy31;
	case '#':	goto yy33;
	case '&':
	case '\'':
	case '(':
	case ')':
	case ',':
	case '.':
	case ':':
	case ';':
	case '?':
	case '@':
	case '[':
	case '\\':
	case ']':
	case '_':
	case '`':
	case '{':
	case '|':
	case '}':
	case '~':	goto yy36;
	case '0':	goto yy38;
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy40;
	default:	goto yy22;
	}
yy20:
	++YYCURSOR;
#line 70 "lex.re"
	{ YYCURSOR--; return TOK_EOF; }
#line 384 "lex.c"
yy22:
	++YYCURSOR;
#line 69 "lex.re"
	{ *b = NULL; return -1; }
#line 389 "lex.c"
yy24:
	++YYCURSOR;
#line 62 "lex.re"
	{ (*column)++; goto loop; }
#line 394 "lex.c"
yy26:
	++YYCURSOR;
#line 61 "lex.re"
	{ (*line)++, *column = 0; goto loop; }
#line 399 "lex.c"
yy28:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '-':
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'G':
	case 'H':
	case 'I':
	case 'J':
	case 'K':
	case 'L':
	case 'M':
	case 'N':
	case 'O':
	case 'P':
	case 'Q':
	case 'R':
	case 'S':
	case 'T':
	case 'U':
	case 'V':
	case 'W':
	case 'X':
	case 'Y':
	case 'Z':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':
	case 'g':
	case 'h':
	case 'i':
	case 'j':
	case 'k':
	case 'l':
	case 'm':
	case 'n':
	case 'o':
	case 'p':
	case 'q':
	case 'r':
	case 's':
	case 't':
	case 'u':
	case 'v':
	case 'w':
	case 'x':
	case 'y':
	case 'z':	goto yy28;
	default:	goto yy30;
	}
yy30:
#line 64 "lex.re"
	{ return TOK_IDENT; }
#line 473 "lex.c"
yy31:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '"':	goto yy43;
	case '\\':	goto yy45;
	default:	goto yy31;
	}
yy33:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\n':	goto yy35;
	default:	goto yy33;
	}
yy35:
#line 63 "lex.re"
	{ goto loop; }
#line 494 "lex.c"
yy36:
	++YYCURSOR;
#line 65 "lex.re"
	{ return **a; }
#line 499 "lex.c"
yy38:
	yych = *(YYMARKER = ++YYCURSOR);
	switch (yych) {
	case 'B':
	case 'b':	goto yy49;
	case 'X':
	case 'x':	goto yy51;
	default:	goto yy48;
	}
yy39:
#line 68 "lex.re"
	{ YYMARKER--; return TOK_INT; }
#line 512 "lex.c"
yy40:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':	goto yy40;
	default:	goto yy42;
	}
yy42:
#line 67 "lex.re"
	{ return TOK_INT; }
#line 533 "lex.c"
yy43:
	++YYCURSOR;
#line 66 "lex.re"
	{ return TOK_STR; }
#line 538 "lex.c"
yy45:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '\\':	goto yy45;
	default:	goto yy31;
	}
yy47:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
yy48:
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':	goto yy47;
	default:	goto yy39;
	}
yy49:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':	goto yy52;
	default:	goto yy50;
	}
yy50:
	YYCURSOR = YYMARKER;
	goto yy39;
yy51:
	yych = *++YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy54;
	default:	goto yy50;
	}
yy52:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '0':
	case '1':	goto yy52;
	default:	goto yy39;
	}
yy54:
	++YYCURSOR;
	if (YYLIMIT <= YYCURSOR) YYFILL(1);
	yych = *YYCURSOR;
	switch (yych) {
	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	case 'A':
	case 'B':
	case 'C':
	case 'D':
	case 'E':
	case 'F':
	case 'a':
	case 'b':
	case 'c':
	case 'd':
	case 'e':
	case 'f':	goto yy54;
	default:	goto yy39;
	}
}
#line 71 "lex.re"

}

static char *
lex_escapes(struct token *t)
{
	char *r = malloc(t->loc.len + 1);
	unsigned j = 0;

	for (unsigned i = 1; i < t->loc.len - 1; i++) {
		if (t->body[i] != '\\') {
			r[j++] = t->body[i];
			continue;
		}
		i++;
		switch (t->body[i]) {
		case 'n': r[j++] = '\n'; break;
		case 't': r[j++] = '\t'; break;
		case '"': r[j++] = '"'; break;
		case '\n': break;
		default:
			r[j++] = '\\';
			r[j++] = t->body[i];
		}
	}

	r[j] = 0;

	return r;
}

struct token *
tok(struct lexer *l, enum mode mode)
{
	struct token *t = malloc(sizeof *t);
	const char *a = l->s + l->loc.idx;
	const char *b = a;

	t->type = mode == CODE
		? lex2(&a, &b, &l->loc.line, &l->loc.column, l->e)
		: lex1(&a, &b, &l->loc.line, &l->loc.column, l->e);
	if (t->type == TOK_EOF) return free(t), NULL;

	/* Assign the basic fields that all tokens have. */

	l->loc.len = b - a;

	t->body = malloc(b - a + 1);
	memcpy(t->body, a, b - a);
	t->body[b - a] = 0;

	t->loc = l->loc;

	/*
	 * `lex()` can't count lines and columns inside token bodies,
	 * so we'll do it here.
	 */

	for (unsigned i = 0; i < l->loc.len; i++) {
		if (t->body[i] == '\n')
			l->loc.line++, l->loc.column = 0;
		else l->loc.column++;
	}

	/* Fill out the type-specific fields. */

	switch (t->type) {
	case TOK_STR:
		t->s = kdgu_news(lex_escapes(t));
		break;
	case TOK_INT:
		t->i = atoi(t->body);
		break;
	default:;
	}

	/*
	 * Update the lexer stream position by moving it to the end of
	 * the current token.
	 */

	l->loc.idx = b - l->s;

	return t;
}

void
print_token(FILE *f, struct token *t)
{
	static char *str[] = {
		"INTEGER",
		"STRING",
		"IDENTIFIER",
		"EOF"
	};

	if (t->type <= TOK_EOF) fprintf(f, "%10s", str[t->type]);
	else fprintf(f, "%10c", t->type);

	fprintf(f, " | %3u | %3u:%2u | %s\n", t->loc.idx,
	        t->loc.line + 1, t->loc.column, t->body);
}
